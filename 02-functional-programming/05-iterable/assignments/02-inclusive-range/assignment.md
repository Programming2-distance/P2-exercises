## Task

You probably have encountered `range` before.
In older versions of Python (pre 3.0), `range` would simply return a list:

```python
# pre Python 3.0
>>> range(10)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

However, for large ranges, creating this list would take time and memory.
From Python 3.0 on, `range` is actually a class.

Say you iterate over a `range` object:

```python
for i in range(10):
  # ...
```

Here, `range(10)` creates a `range`-object.
This object is _iterable_, but not an _iterator_.
The `for`-loop needs an _iterator_`, so it uses `iter` to have the iterable create an iterator.
Calling `next` on this iterator produces all the elements of the range.

Create your own `InclusiveRange` (= iterable) and accompanying `InclusiveRangeIterator` (=iterator) class.
It should be usable as follows:

```python
>>> for i in InclusiveRange(1, 5)
...     print(i)
1
2
3
4
5
```

For this to work, `InclusiveRange` needs an `__iter__` method that returns a `InclusiveRangeIterator` object.
`InclusiveRangeIterator` should implement `__iter__` (just have it return `self`) and `__next__`.

Note that `InclusiveRange` should be reusable, but `InclusiveRangeIterator` should be single use:

```python
>>> r = InclusiveRange(1, 5)
>>> list(r)
[1, 2, 3, 4, 5]

>>> list(r)
[1, 2, 3, 4, 5]


>>> iterator = iter(r)
>>> list(iterator)
[1, 2, 3, 4, 5]

# We've used up the iterator, so no more elements are generated by it
>>> list(iterator)
[]
```
